
pkg console

@Define _printIntSetup;
    # rax = number
    mov rbx, rax;                 # working copy
    mov rdi, _numbuf + 20;        # write pointer (end of buffer)
    mov byte [rdi], 0;            # null terminate
@End

@Define _printIntBegin;
    # sign?
    mov rcx, 0;                   # rcx = sign flag
    cmp rbx, 0;
    jge .Dg;
    neg rbx;
    mov rcx, 1;    
@End

@Define _printIntDg;
.Dg:
    # convert decimal digits backwards
    xor rdx, rdx;
    mov rax, rbx;
    mov rsi, 10;
    div rsi;                      # rax = rbx/10, rdx = rbx % 10
    add rdx, 48;                  # turn digit into ASCII (48 = ASCII '0')
    dec rdi;
    mov byte [rdi], dl;           # write one character
    mov rbx, rax;
    test rbx, rbx;
    jnz .Dg;
@End

@Define _printIntMaybeNegativeSign;
    # negative sign
    cmp rcx, 0;
    je .Wr;
    dec rdi;
    mov byte [rdi], 45; # 45 = ASCII '-'
@End

@Define _printIntAddNewline;
    # add newline
    dec rdi;
    mov byte [rdi], 10;
@End

@Define _printIntWr;
.Wr:
    # now string is at [rdi ...]
    mov rax, 1;                   # syscall: write
    mov rsi, rdi;                 # buffer address
    # find length: end = _numbuf+20
    mov rdx, _numbuf + 20;
    sub rdx, rdi;
    mov rdi, 1;                   # stdout
    syscall;
@End

@Define _printCharacter;
    push rax;            # save caller's RAX if needed
                         # also gives us a place to store the char

    mov rdi, 1;          # stdout
    mov rsi, rsp;        # pointer to stored char
    mov rdx, 1;          # write 1 byte
    mov rax, 1;          # syscall: write
    syscall;

    pop rax;             # restore original RAX
@End

export defn print(x: int) {
    x
    @Asmbl { _printIntSetup }
    @Asmbl { _printIntBegin }
    @Asmbl { _printIntDg }
    @Asmbl { _printIntMaybeNegativeSign }
    @Asmbl { _printIntWr }
}

export defn printl(x: int) {
    x
    @Asmbl { _printIntSetup }
    @Asmbl { _printIntAddNewline }
    @Asmbl { _printIntBegin }
    @Asmbl { _printIntDg }
    @Asmbl { _printIntMaybeNegativeSign }
    @Asmbl { _printIntWr }
}

defn print(x: char) {
    x
    @Asmbl { _printCharacter }
}

defn printl(x: char) {
    x
    @Asmbl { _printCharacter }
    '\n'
    @Asmbl { _printCharacter }
}

defn print(x: char[]) {
    for (i: mut = 0; i < x.sizeof; ++i) {
        x[i]
        @Asmbl { _printCharacter }
    }
}

defn printl(x: char[]) {
    for (i: mut = 0; i < x.sizeof; ++i) {
        x[i]
        @Asmbl { _printCharacter }
    }
    '\n'
    @Asmbl { _printCharacter }
}

defn printl {
    '\n'
    @Asmbl { _printCharacter }
}

defn main {
    printl('Hello, World!')
}
