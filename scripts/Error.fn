// header for basic error handling using signals
// basic example:

// #include "Error.fn"
//
// do: // start of the try statement
//     // ~> means broadcast signal
//     ~> Error(ErrLvl::Error, "Message")
//
// with Error_t e: // receive the signal
//     Std::IO::WriteLn("Error: ", e)
// esc

// error levels:

// do: ~> Error(ErrLvl::Error, "Message")
// with Error_t e:
//     if e.Level == ErrLvl::Error:
//         Std::IO::WriteLn("An error occurred:\n", e.Message)
//     else e.Level == ErrLvl::Fatal:
//         Std::IO::WriteLn("A fatal error has occurred:\n", e.Message)
//         Std::IO::WriteLn("Closing the program due to the unexpected error.")
//         Std::Exit(1)
//     esc
// esc

// source:

// Macro for the error type
// (string map with an error level and message)
#macro Error_t = {} of <string>;

// Error level type is just a string:
// eg. 'DeprecationWarning'
#macro ErrLvl_t = string; 

// Library containing basic error types
// Use this instead of string literals
// when throwing errors
lib ErrLvl:
    ErrLvl_t Warning = 'Warning'
    ErrLvl_t Deprecated = 'DeprecationWarning' // = No longer being supported or updated
    ErrLvl_t Error = 'Error' // Common error
    ErrLvl_t Fatal = 'Fatal'
esc

// Error_t to string
// __ToString method
// Example string:
// Error (DeprecationWarning):
// 'This function is deprectated will no longer be supported, not recommended to use in future work.'
fn ErrorToString(Error_t self) string
    => use string("Error (", self.Level, "):\n", self.Message)

// Metamethods for Error_t
var {} of <null> ErrorMeta = {
    (null)
    // The Furn interpreter does not type check
    // double underscore (__) keys in maps
    ['__ToString']: ErrorToString,
}

// Constructor to create a new Error_t
fn Error(ErrLvl_t Level, string Message) Error_t // {} of <string>
=> {
    (string)
    ['Level']: Level,
    ['Message']: Message,
    ['__Meta']: ErrorMeta, // Auto called by the Furn interpreter
}
